/*  ==============================================================================
 *  Created by Fehmi Demiralp(Fedem) on 2025-06-08 GMT
 *  Copyright (C) 2023-2025 Fedem (Fehmi Demiralp) <f.demiralp@gmail.com>
 *
 *  This file is generated by UMTSM using the code generator `CppGen`
 *
 *  !!! It is highly recommended that DO NOT EDIT THIS GENERATED FILE !!!
 *
 *  Released under the MIT License
 *  ==============================================================================
 */

/*  Copyright (C) 2023-2025 Fedem (Fehmi Demiralp) <f.demiralp@gmail.com>
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the "Software"), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in all
 *  copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *  SOFTWARE.
 */

#include "Crossroad.hh"

#include <cassert>
#include <csignal>
#include <cstddef>
#include <cstring>
#include <mutex>
#include <optional>
#include <thread>

Crossroad::Crossroad( )
{
  initialize( );
}

Crossroad::~Crossroad( )
{
  deinitialize( );
}

void Crossroad::initialize( )
{
  std::lock_guard<std::mutex> lockGuard( guard );;

  instanceData.initialize( );
  runningState.Main = Main_States::E_init;

  subSM.Lane1.initialize( );
  subSM.Lane2.initialize( );
  subSM.Lane3.initialize( );
  subSM.Lane4.initialize( );
  subSM.PedestrianLanes.initialize( );
  subSM.TrafficLight1.initialize( );
  subSM.TrafficLight2.initialize( );
  subSM.TrafficLight3.initialize( );
  subSM.TrafficLight4.initialize( );
  subSM.PedestrianLight.initialize( );
}

void Crossroad::deinitialize( )
{
  std::lock_guard<std::mutex> lockGuard( guard );;

  terminate( );
  runningState.Main = Main_States::E_final;

  instanceData.deinitialize( );
}

void Crossroad::start( )
{
  if ( ! isIn_Main_Region( ) )
  {
    std::lock_guard<std::mutex> lockGuard( guard );

    init_Main( );
  }
}

void Crossroad::halt( )
{
  finalize_Main( );
}

bool Crossroad::isReady( ) const noexcept
{
  auto const ready = ( runningState.Main == Main_States::E_init );
  return ready;
}

bool Crossroad::isAlive( ) const noexcept
{
  auto const alive = isIn_Main_Region( );
  return alive;
}

bool Crossroad::isTerminated( ) const noexcept
{
  auto const terminated = ( runningState.Main == Main_States::E_final );
  return terminated;
}

bool Crossroad::is_Main_Region_Ready( ) const noexcept
{
  auto const ready = ( runningState.Main == Main_States::E_init );
  return ready;
}

bool Crossroad::is_RgLane1_Region_Ready( ) const noexcept
{
  auto const ready = ( runningState.RgLane1 == RgLane1_States::E_init );
  return ready;
}

bool Crossroad::is_RgLane2_Region_Ready( ) const noexcept
{
  auto const ready = ( runningState.RgLane2 == RgLane2_States::E_init );
  return ready;
}

bool Crossroad::is_RgLane3_Region_Ready( ) const noexcept
{
  auto const ready = ( runningState.RgLane3 == RgLane3_States::E_init );
  return ready;
}

bool Crossroad::is_RgLane4_Region_Ready( ) const noexcept
{
  auto const ready = ( runningState.RgLane4 == RgLane4_States::E_init );
  return ready;
}

bool Crossroad::is_RgPedestrianLanes_Region_Ready( ) const noexcept
{
  auto const ready = ( runningState.RgPedestrianLanes == RgPedestrianLanes_States::E_init );
  return ready;
}

bool Crossroad::is_RgTrafficLight1_Region_Ready( ) const noexcept
{
  auto const ready = ( runningState.RgTrafficLight1 == RgTrafficLight1_States::E_init );
  return ready;
}

bool Crossroad::is_RgTrafficLight2_Region_Ready( ) const noexcept
{
  auto const ready = ( runningState.RgTrafficLight2 == RgTrafficLight2_States::E_init );
  return ready;
}

bool Crossroad::is_RgTrafficLight3_Region_Ready( ) const noexcept
{
  auto const ready = ( runningState.RgTrafficLight3 == RgTrafficLight3_States::E_init );
  return ready;
}

bool Crossroad::is_RgTrafficLight4_Region_Ready( ) const noexcept
{
  auto const ready = ( runningState.RgTrafficLight4 == RgTrafficLight4_States::E_init );
  return ready;
}

bool Crossroad::is_RgPedestrianLight_Region_Ready( ) const noexcept
{
  auto const ready = ( runningState.RgPedestrianLight == RgPedestrianLight_States::E_init );
  return ready;
}

bool Crossroad::is_Main_Region_Terminated( ) const noexcept
{
  auto const terminated = ( runningState.Main == Main_States::E_final );
  return terminated;
}

bool Crossroad::is_RgLane1_Region_Terminated( ) const noexcept
{
  auto const terminated = ( runningState.RgLane1 == RgLane1_States::E_final );
  return terminated;
}

bool Crossroad::is_RgLane2_Region_Terminated( ) const noexcept
{
  auto const terminated = ( runningState.RgLane2 == RgLane2_States::E_final );
  return terminated;
}

bool Crossroad::is_RgLane3_Region_Terminated( ) const noexcept
{
  auto const terminated = ( runningState.RgLane3 == RgLane3_States::E_final );
  return terminated;
}

bool Crossroad::is_RgLane4_Region_Terminated( ) const noexcept
{
  auto const terminated = ( runningState.RgLane4 == RgLane4_States::E_final );
  return terminated;
}

bool Crossroad::is_RgPedestrianLanes_Region_Terminated( ) const noexcept
{
  auto const terminated = ( runningState.RgPedestrianLanes == RgPedestrianLanes_States::E_final );
  return terminated;
}

bool Crossroad::is_RgTrafficLight1_Region_Terminated( ) const noexcept
{
  auto const terminated = ( runningState.RgTrafficLight1 == RgTrafficLight1_States::E_final );
  return terminated;
}

bool Crossroad::is_RgTrafficLight2_Region_Terminated( ) const noexcept
{
  auto const terminated = ( runningState.RgTrafficLight2 == RgTrafficLight2_States::E_final );
  return terminated;
}

bool Crossroad::is_RgTrafficLight3_Region_Terminated( ) const noexcept
{
  auto const terminated = ( runningState.RgTrafficLight3 == RgTrafficLight3_States::E_final );
  return terminated;
}

bool Crossroad::is_RgTrafficLight4_Region_Terminated( ) const noexcept
{
  auto const terminated = ( runningState.RgTrafficLight4 == RgTrafficLight4_States::E_final );
  return terminated;
}

bool Crossroad::is_RgPedestrianLight_Region_Terminated( ) const noexcept
{
  auto const terminated = ( runningState.RgPedestrianLight == RgPedestrianLight_States::E_final );
  return terminated;
}

bool Crossroad::isIn_Main_Region( ) const noexcept
{
  bool const result = ( runningState.Main != Main_States::E_init ) &&
                      ( runningState.Main != Main_States::E_final );

  return result;
}

bool Crossroad::isIn_RgLane1_Region( ) const noexcept
{
  bool const result = ( runningState.RgLane1 != RgLane1_States::E_init ) &&
                      ( runningState.RgLane1 != RgLane1_States::E_final ) &&
                      isIn_Main_State( );

  return result;
}

bool Crossroad::isIn_RgLane2_Region( ) const noexcept
{
  bool const result = ( runningState.RgLane2 != RgLane2_States::E_init ) &&
                      ( runningState.RgLane2 != RgLane2_States::E_final ) &&
                      isIn_Main_State( );

  return result;
}

bool Crossroad::isIn_RgLane3_Region( ) const noexcept
{
  bool const result = ( runningState.RgLane3 != RgLane3_States::E_init ) &&
                      ( runningState.RgLane3 != RgLane3_States::E_final ) &&
                      isIn_Main_State( );

  return result;
}

bool Crossroad::isIn_RgLane4_Region( ) const noexcept
{
  bool const result = ( runningState.RgLane4 != RgLane4_States::E_init ) &&
                      ( runningState.RgLane4 != RgLane4_States::E_final ) &&
                      isIn_Main_State( );

  return result;
}

bool Crossroad::isIn_RgPedestrianLanes_Region( ) const noexcept
{
  bool const result = ( runningState.RgPedestrianLanes != RgPedestrianLanes_States::E_init ) &&
                      ( runningState.RgPedestrianLanes != RgPedestrianLanes_States::E_final ) &&
                      isIn_Main_State( );

  return result;
}

bool Crossroad::isIn_RgTrafficLight1_Region( ) const noexcept
{
  bool const result = ( runningState.RgTrafficLight1 != RgTrafficLight1_States::E_init ) &&
                      ( runningState.RgTrafficLight1 != RgTrafficLight1_States::E_final ) &&
                      isIn_Main_State( );

  return result;
}

bool Crossroad::isIn_RgTrafficLight2_Region( ) const noexcept
{
  bool const result = ( runningState.RgTrafficLight2 != RgTrafficLight2_States::E_init ) &&
                      ( runningState.RgTrafficLight2 != RgTrafficLight2_States::E_final ) &&
                      isIn_Main_State( );

  return result;
}

bool Crossroad::isIn_RgTrafficLight3_Region( ) const noexcept
{
  bool const result = ( runningState.RgTrafficLight3 != RgTrafficLight3_States::E_init ) &&
                      ( runningState.RgTrafficLight3 != RgTrafficLight3_States::E_final ) &&
                      isIn_Main_State( );

  return result;
}

bool Crossroad::isIn_RgTrafficLight4_Region( ) const noexcept
{
  bool const result = ( runningState.RgTrafficLight4 != RgTrafficLight4_States::E_init ) &&
                      ( runningState.RgTrafficLight4 != RgTrafficLight4_States::E_final ) &&
                      isIn_Main_State( );

  return result;
}

bool Crossroad::isIn_RgPedestrianLight_Region( ) const noexcept
{
  bool const result = ( runningState.RgPedestrianLight != RgPedestrianLight_States::E_init ) &&
                      ( runningState.RgPedestrianLight != RgPedestrianLight_States::E_final ) &&
                      isIn_Main_State( );

  return result;
}

bool Crossroad::isIn_Main_State( ) const noexcept
{
  bool const result = isIn_Main_Region( ) &&
    ( runningState.Main == Main_States::E_Main );

  return result;
}

bool Crossroad::isIn_Lane1_State( ) const noexcept
{
  bool const result = isIn_RgLane1_Region( ) &&
    ( runningState.RgLane1 == RgLane1_States::E_Lane1 );

  return result;
}

bool Crossroad::isIn_Lane2_State( ) const noexcept
{
  bool const result = isIn_RgLane2_Region( ) &&
    ( runningState.RgLane2 == RgLane2_States::E_Lane2 );

  return result;
}

bool Crossroad::isIn_Lane3_State( ) const noexcept
{
  bool const result = isIn_RgLane3_Region( ) &&
    ( runningState.RgLane3 == RgLane3_States::E_Lane3 );

  return result;
}

bool Crossroad::isIn_Lane4_State( ) const noexcept
{
  bool const result = isIn_RgLane4_Region( ) &&
    ( runningState.RgLane4 == RgLane4_States::E_Lane4 );

  return result;
}

bool Crossroad::isIn_PedestrianLanes_State( ) const noexcept
{
  bool const result = isIn_RgPedestrianLanes_Region( ) &&
    ( runningState.RgPedestrianLanes == RgPedestrianLanes_States::E_PedestrianLanes );

  return result;
}

bool Crossroad::isIn_TrafficLight1_State( ) const noexcept
{
  bool const result = isIn_RgTrafficLight1_Region( ) &&
    ( runningState.RgTrafficLight1 == RgTrafficLight1_States::E_TrafficLight1 );

  return result;
}

bool Crossroad::isIn_TrafficLight2_State( ) const noexcept
{
  bool const result = isIn_RgTrafficLight2_Region( ) &&
    ( runningState.RgTrafficLight2 == RgTrafficLight2_States::E_TrafficLight2 );

  return result;
}

bool Crossroad::isIn_TrafficLight3_State( ) const noexcept
{
  bool const result = isIn_RgTrafficLight3_Region( ) &&
    ( runningState.RgTrafficLight3 == RgTrafficLight3_States::E_TrafficLight3 );

  return result;
}

bool Crossroad::isIn_TrafficLight4_State( ) const noexcept
{
  bool const result = isIn_RgTrafficLight4_Region( ) &&
    ( runningState.RgTrafficLight4 == RgTrafficLight4_States::E_TrafficLight4 );

  return result;
}

bool Crossroad::isIn_PedestrianLight_State( ) const noexcept
{
  bool const result = isIn_RgPedestrianLight_Region( ) &&
    ( runningState.RgPedestrianLight == RgPedestrianLight_States::E_PedestrianLight );

  return result;
}

Crossroad_DataType* Crossroad::getData( ) noexcept
{
  Crossroad_DataType* const pCustomData = &instanceData;
  return pCustomData;
}

Lane_DataType* Crossroad::getSMData_Lane1( ) noexcept
{
  Lane_DataType* const pCustomData = subSM.Lane1.getData( );
  return pCustomData;
}

Lane_DataType* Crossroad::getSMData_Lane2( ) noexcept
{
  Lane_DataType* const pCustomData = subSM.Lane2.getData( );
  return pCustomData;
}

Lane_DataType* Crossroad::getSMData_Lane3( ) noexcept
{
  Lane_DataType* const pCustomData = subSM.Lane3.getData( );
  return pCustomData;
}

Lane_DataType* Crossroad::getSMData_Lane4( ) noexcept
{
  Lane_DataType* const pCustomData = subSM.Lane4.getData( );
  return pCustomData;
}

Lane_DataType* Crossroad::getSMData_PedestrianLanes( ) noexcept
{
  Lane_DataType* const pCustomData = subSM.PedestrianLanes.getData( );
  return pCustomData;
}

TrafficLight_DataType* Crossroad::getSMData_TrafficLight1( ) noexcept
{
  TrafficLight_DataType* const pCustomData = subSM.TrafficLight1.getData( );
  return pCustomData;
}

TrafficLight_DataType* Crossroad::getSMData_TrafficLight2( ) noexcept
{
  TrafficLight_DataType* const pCustomData = subSM.TrafficLight2.getData( );
  return pCustomData;
}

TrafficLight_DataType* Crossroad::getSMData_TrafficLight3( ) noexcept
{
  TrafficLight_DataType* const pCustomData = subSM.TrafficLight3.getData( );
  return pCustomData;
}

TrafficLight_DataType* Crossroad::getSMData_TrafficLight4( ) noexcept
{
  TrafficLight_DataType* const pCustomData = subSM.TrafficLight4.getData( );
  return pCustomData;
}

PedestrianLights_DataType* Crossroad::getSMData_PedestrianLight( ) noexcept
{
  PedestrianLights_DataType* const pCustomData = subSM.PedestrianLight.getData( );
  return pCustomData;
}

Lane* Crossroad::getSubSM_Lane1( ) noexcept
{
  Lane* const pSubSM = &subSM.Lane1;
  return pSubSM;
}

Lane* Crossroad::getSubSM_Lane2( ) noexcept
{
  Lane* const pSubSM = &subSM.Lane2;
  return pSubSM;
}

Lane* Crossroad::getSubSM_Lane3( ) noexcept
{
  Lane* const pSubSM = &subSM.Lane3;
  return pSubSM;
}

Lane* Crossroad::getSubSM_Lane4( ) noexcept
{
  Lane* const pSubSM = &subSM.Lane4;
  return pSubSM;
}

Lane* Crossroad::getSubSM_PedestrianLanes( ) noexcept
{
  Lane* const pSubSM = &subSM.PedestrianLanes;
  return pSubSM;
}

TrafficLight* Crossroad::getSubSM_TrafficLight1( ) noexcept
{
  TrafficLight* const pSubSM = &subSM.TrafficLight1;
  return pSubSM;
}

TrafficLight* Crossroad::getSubSM_TrafficLight2( ) noexcept
{
  TrafficLight* const pSubSM = &subSM.TrafficLight2;
  return pSubSM;
}

TrafficLight* Crossroad::getSubSM_TrafficLight3( ) noexcept
{
  TrafficLight* const pSubSM = &subSM.TrafficLight3;
  return pSubSM;
}

TrafficLight* Crossroad::getSubSM_TrafficLight4( ) noexcept
{
  TrafficLight* const pSubSM = &subSM.TrafficLight4;
  return pSubSM;
}

PedestrianLights* Crossroad::getSubSM_PedestrianLight( ) noexcept
{
  PedestrianLights* const pSubSM = &subSM.PedestrianLight;
  return pSubSM;
}

void Crossroad::subSMTrigger_Allowed( SubstateMachines subsm )
{
  switch ( subsm )
  {
    case SubstateMachines::E_Self:
    {
      trigger_Allowed( );
      break;
    }
    case SubstateMachines::E_SubSM_Lane1:
    {
      subSM.Lane1.trigger_Allowed( );
      break;
    }
    case SubstateMachines::E_SubSM_Lane2:
    {
      subSM.Lane2.trigger_Allowed( );
      break;
    }
    case SubstateMachines::E_SubSM_Lane3:
    {
      subSM.Lane3.trigger_Allowed( );
      break;
    }
    case SubstateMachines::E_SubSM_Lane4:
    {
      subSM.Lane4.trigger_Allowed( );
      break;
    }
    case SubstateMachines::E_SubSM_PedestrianLanes:
    {
      subSM.PedestrianLanes.trigger_Allowed( );
      break;
    }
    default:
    {
      // the other state machine(s) do not support trigger `Allowed`
      break;
    }
  }
}

void Crossroad::subSMTrigger_Check( SubstateMachines subsm )
{
  switch ( subsm )
  {
    case SubstateMachines::E_Self:
    {
      trigger_Check( );
      break;
    }
    case SubstateMachines::E_SubSM_TrafficLight1:
    {
      subSM.TrafficLight1.trigger_Check( );
      break;
    }
    case SubstateMachines::E_SubSM_TrafficLight2:
    {
      subSM.TrafficLight2.trigger_Check( );
      break;
    }
    case SubstateMachines::E_SubSM_TrafficLight3:
    {
      subSM.TrafficLight3.trigger_Check( );
      break;
    }
    case SubstateMachines::E_SubSM_TrafficLight4:
    {
      subSM.TrafficLight4.trigger_Check( );
      break;
    }
    case SubstateMachines::E_SubSM_PedestrianLight:
    {
      subSM.PedestrianLight.trigger_Check( );
      break;
    }
    default:
    {
      // the other state machine(s) do not support trigger `Check`
      break;
    }
  }
}

void Crossroad::subSMTrigger_Close( SubstateMachines subsm )
{
  switch ( subsm )
  {
    case SubstateMachines::E_Self:
    {
      trigger_Close( );
      break;
    }
    case SubstateMachines::E_SubSM_Lane1:
    {
      subSM.Lane1.trigger_Close( );
      break;
    }
    case SubstateMachines::E_SubSM_Lane2:
    {
      subSM.Lane2.trigger_Close( );
      break;
    }
    case SubstateMachines::E_SubSM_Lane3:
    {
      subSM.Lane3.trigger_Close( );
      break;
    }
    case SubstateMachines::E_SubSM_Lane4:
    {
      subSM.Lane4.trigger_Close( );
      break;
    }
    case SubstateMachines::E_SubSM_PedestrianLanes:
    {
      subSM.PedestrianLanes.trigger_Close( );
      break;
    }
    default:
    {
      // the other state machine(s) do not support trigger `Close`
      break;
    }
  }
}

void Crossroad::subSMTrigger_Disallowed( SubstateMachines subsm )
{
  switch ( subsm )
  {
    case SubstateMachines::E_Self:
    {
      trigger_Disallowed( );
      break;
    }
    case SubstateMachines::E_SubSM_Lane1:
    {
      subSM.Lane1.trigger_Disallowed( );
      break;
    }
    case SubstateMachines::E_SubSM_Lane2:
    {
      subSM.Lane2.trigger_Disallowed( );
      break;
    }
    case SubstateMachines::E_SubSM_Lane3:
    {
      subSM.Lane3.trigger_Disallowed( );
      break;
    }
    case SubstateMachines::E_SubSM_Lane4:
    {
      subSM.Lane4.trigger_Disallowed( );
      break;
    }
    case SubstateMachines::E_SubSM_PedestrianLanes:
    {
      subSM.PedestrianLanes.trigger_Disallowed( );
      break;
    }
    default:
    {
      // the other state machine(s) do not support trigger `Disallowed`
      break;
    }
  }
}

void Crossroad::subSMTrigger_Open( SubstateMachines subsm )
{
  switch ( subsm )
  {
    case SubstateMachines::E_Self:
    {
      trigger_Open( );
      break;
    }
    case SubstateMachines::E_SubSM_Lane1:
    {
      subSM.Lane1.trigger_Open( );
      break;
    }
    case SubstateMachines::E_SubSM_Lane2:
    {
      subSM.Lane2.trigger_Open( );
      break;
    }
    case SubstateMachines::E_SubSM_Lane3:
    {
      subSM.Lane3.trigger_Open( );
      break;
    }
    case SubstateMachines::E_SubSM_Lane4:
    {
      subSM.Lane4.trigger_Open( );
      break;
    }
    case SubstateMachines::E_SubSM_PedestrianLanes:
    {
      subSM.PedestrianLanes.trigger_Open( );
      break;
    }
    default:
    {
      // the other state machine(s) do not support trigger `Open`
      break;
    }
  }
}

void Crossroad::subSMTrigger_Prepare( SubstateMachines subsm )
{
  switch ( subsm )
  {
    case SubstateMachines::E_Self:
    {
      trigger_Prepare( );
      break;
    }
    case SubstateMachines::E_SubSM_Lane1:
    {
      subSM.Lane1.trigger_Prepare( );
      break;
    }
    case SubstateMachines::E_SubSM_Lane2:
    {
      subSM.Lane2.trigger_Prepare( );
      break;
    }
    case SubstateMachines::E_SubSM_Lane3:
    {
      subSM.Lane3.trigger_Prepare( );
      break;
    }
    case SubstateMachines::E_SubSM_Lane4:
    {
      subSM.Lane4.trigger_Prepare( );
      break;
    }
    case SubstateMachines::E_SubSM_PedestrianLanes:
    {
      subSM.PedestrianLanes.trigger_Prepare( );
      break;
    }
    default:
    {
      // the other state machine(s) do not support trigger `Prepare`
      break;
    }
  }
}

void Crossroad::subSMTrigger_StartControlling( SubstateMachines subsm )
{
  switch ( subsm )
  {
    case SubstateMachines::E_Self:
    {
      trigger_StartControlling( );
      break;
    }
    case SubstateMachines::E_SubSM_Lane1:
    {
      subSM.Lane1.trigger_StartControlling( );
      break;
    }
    case SubstateMachines::E_SubSM_Lane2:
    {
      subSM.Lane2.trigger_StartControlling( );
      break;
    }
    case SubstateMachines::E_SubSM_Lane3:
    {
      subSM.Lane3.trigger_StartControlling( );
      break;
    }
    case SubstateMachines::E_SubSM_Lane4:
    {
      subSM.Lane4.trigger_StartControlling( );
      break;
    }
    case SubstateMachines::E_SubSM_PedestrianLanes:
    {
      subSM.PedestrianLanes.trigger_StartControlling( );
      break;
    }
    default:
    {
      // the other state machine(s) do not support trigger `StartControlling`
      break;
    }
  }
}

void Crossroad::subSMTrigger_StopControlling( SubstateMachines subsm )
{
  switch ( subsm )
  {
    case SubstateMachines::E_Self:
    {
      trigger_StopControlling( );
      break;
    }
    case SubstateMachines::E_SubSM_Lane1:
    {
      subSM.Lane1.trigger_StopControlling( );
      break;
    }
    case SubstateMachines::E_SubSM_Lane2:
    {
      subSM.Lane2.trigger_StopControlling( );
      break;
    }
    case SubstateMachines::E_SubSM_Lane3:
    {
      subSM.Lane3.trigger_StopControlling( );
      break;
    }
    case SubstateMachines::E_SubSM_Lane4:
    {
      subSM.Lane4.trigger_StopControlling( );
      break;
    }
    case SubstateMachines::E_SubSM_PedestrianLanes:
    {
      subSM.PedestrianLanes.trigger_StopControlling( );
      break;
    }
    default:
    {
      // the other state machine(s) do not support trigger `StopControlling`
      break;
    }
  }
}

void Crossroad::subSMTrigger_SystemEnabled( SubstateMachines subsm )
{
  switch ( subsm )
  {
    case SubstateMachines::E_Self:
    {
      trigger_SystemEnabled( );
      break;
    }
    case SubstateMachines::E_SubSM_TrafficLight1:
    {
      subSM.TrafficLight1.trigger_SystemEnabled( );
      break;
    }
    case SubstateMachines::E_SubSM_TrafficLight2:
    {
      subSM.TrafficLight2.trigger_SystemEnabled( );
      break;
    }
    case SubstateMachines::E_SubSM_TrafficLight3:
    {
      subSM.TrafficLight3.trigger_SystemEnabled( );
      break;
    }
    case SubstateMachines::E_SubSM_TrafficLight4:
    {
      subSM.TrafficLight4.trigger_SystemEnabled( );
      break;
    }
    case SubstateMachines::E_SubSM_PedestrianLight:
    {
      subSM.PedestrianLight.trigger_SystemEnabled( );
      break;
    }
    default:
    {
      // the other state machine(s) do not support trigger `SystemEnabled`
      break;
    }
  }
}

void Crossroad::trigger_Allowed( )
{
  __attribute__( ( unused ) ) bool doneMain = false;
  __attribute__( ( unused ) ) bool doneRgLane1 = false;
  __attribute__( ( unused ) ) bool doneRgLane2 = false;
  __attribute__( ( unused ) ) bool doneRgLane3 = false;
  __attribute__( ( unused ) ) bool doneRgLane4 = false;
  __attribute__( ( unused ) ) bool doneRgPedestrianLanes = false;

  std::lock_guard<std::mutex> lockGuard( guard );

  if ( isIn_RgLane1_Region( ) )
  {
    doneRgLane1 = true;

    if ( isIn_Lane1_State( ) )
    {
      subSM.Lane1.trigger_Allowed( );
    }
    else
    {
      doneRgLane1 = false;
    }
  }

  if ( isIn_RgLane2_Region( ) )
  {
    doneRgLane2 = true;

    if ( isIn_Lane2_State( ) )
    {
      subSM.Lane2.trigger_Allowed( );
    }
    else
    {
      doneRgLane2 = false;
    }
  }

  if ( isIn_RgLane3_Region( ) )
  {
    doneRgLane3 = true;

    if ( isIn_Lane3_State( ) )
    {
      subSM.Lane3.trigger_Allowed( );
    }
    else
    {
      doneRgLane3 = false;
    }
  }

  if ( isIn_RgLane4_Region( ) )
  {
    doneRgLane4 = true;

    if ( isIn_Lane4_State( ) )
    {
      subSM.Lane4.trigger_Allowed( );
    }
    else
    {
      doneRgLane4 = false;
    }
  }

  if ( isIn_RgPedestrianLanes_Region( ) )
  {
    doneRgPedestrianLanes = true;

    if ( isIn_PedestrianLanes_State( ) )
    {
      subSM.PedestrianLanes.trigger_Allowed( );
    }
    else
    {
      doneRgPedestrianLanes = false;
    }
  }
}

void Crossroad::trigger_Check( )
{
  __attribute__( ( unused ) ) bool doneMain = false;
  __attribute__( ( unused ) ) bool doneRgTrafficLight1 = false;
  __attribute__( ( unused ) ) bool doneRgTrafficLight2 = false;
  __attribute__( ( unused ) ) bool doneRgTrafficLight3 = false;
  __attribute__( ( unused ) ) bool doneRgTrafficLight4 = false;
  __attribute__( ( unused ) ) bool doneRgPedestrianLight = false;

  std::lock_guard<std::mutex> lockGuard( guard );

  if ( isIn_RgTrafficLight1_Region( ) )
  {
    doneRgTrafficLight1 = true;

    if ( isIn_TrafficLight1_State( ) )
    {
      subSM.TrafficLight1.trigger_Check( );
    }
    else
    {
      doneRgTrafficLight1 = false;
    }
  }

  if ( isIn_RgTrafficLight2_Region( ) )
  {
    doneRgTrafficLight2 = true;

    if ( isIn_TrafficLight2_State( ) )
    {
      subSM.TrafficLight2.trigger_Check( );
    }
    else
    {
      doneRgTrafficLight2 = false;
    }
  }

  if ( isIn_RgTrafficLight3_Region( ) )
  {
    doneRgTrafficLight3 = true;

    if ( isIn_TrafficLight3_State( ) )
    {
      subSM.TrafficLight3.trigger_Check( );
    }
    else
    {
      doneRgTrafficLight3 = false;
    }
  }

  if ( isIn_RgTrafficLight4_Region( ) )
  {
    doneRgTrafficLight4 = true;

    if ( isIn_TrafficLight4_State( ) )
    {
      subSM.TrafficLight4.trigger_Check( );
    }
    else
    {
      doneRgTrafficLight4 = false;
    }
  }

  if ( isIn_RgPedestrianLight_Region( ) )
  {
    doneRgPedestrianLight = true;

    if ( isIn_PedestrianLight_State( ) )
    {
      subSM.PedestrianLight.trigger_Check( );
    }
    else
    {
      doneRgPedestrianLight = false;
    }
  }
}

void Crossroad::trigger_Close( )
{
  __attribute__( ( unused ) ) bool doneMain = false;
  __attribute__( ( unused ) ) bool doneRgLane1 = false;
  __attribute__( ( unused ) ) bool doneRgLane2 = false;
  __attribute__( ( unused ) ) bool doneRgLane3 = false;
  __attribute__( ( unused ) ) bool doneRgLane4 = false;
  __attribute__( ( unused ) ) bool doneRgPedestrianLanes = false;

  std::lock_guard<std::mutex> lockGuard( guard );

  if ( isIn_RgLane1_Region( ) )
  {
    doneRgLane1 = true;

    if ( isIn_Lane1_State( ) )
    {
      subSM.Lane1.trigger_Close( );
    }
    else
    {
      doneRgLane1 = false;
    }
  }

  if ( isIn_RgLane2_Region( ) )
  {
    doneRgLane2 = true;

    if ( isIn_Lane2_State( ) )
    {
      subSM.Lane2.trigger_Close( );
    }
    else
    {
      doneRgLane2 = false;
    }
  }

  if ( isIn_RgLane3_Region( ) )
  {
    doneRgLane3 = true;

    if ( isIn_Lane3_State( ) )
    {
      subSM.Lane3.trigger_Close( );
    }
    else
    {
      doneRgLane3 = false;
    }
  }

  if ( isIn_RgLane4_Region( ) )
  {
    doneRgLane4 = true;

    if ( isIn_Lane4_State( ) )
    {
      subSM.Lane4.trigger_Close( );
    }
    else
    {
      doneRgLane4 = false;
    }
  }

  if ( isIn_RgPedestrianLanes_Region( ) )
  {
    doneRgPedestrianLanes = true;

    if ( isIn_PedestrianLanes_State( ) )
    {
      subSM.PedestrianLanes.trigger_Close( );
    }
    else
    {
      doneRgPedestrianLanes = false;
    }
  }
}

void Crossroad::trigger_Disallowed( )
{
  __attribute__( ( unused ) ) bool doneMain = false;
  __attribute__( ( unused ) ) bool doneRgLane1 = false;
  __attribute__( ( unused ) ) bool doneRgLane2 = false;
  __attribute__( ( unused ) ) bool doneRgLane3 = false;
  __attribute__( ( unused ) ) bool doneRgLane4 = false;
  __attribute__( ( unused ) ) bool doneRgPedestrianLanes = false;

  std::lock_guard<std::mutex> lockGuard( guard );

  if ( isIn_RgLane1_Region( ) )
  {
    doneRgLane1 = true;

    if ( isIn_Lane1_State( ) )
    {
      subSM.Lane1.trigger_Disallowed( );
    }
    else
    {
      doneRgLane1 = false;
    }
  }

  if ( isIn_RgLane2_Region( ) )
  {
    doneRgLane2 = true;

    if ( isIn_Lane2_State( ) )
    {
      subSM.Lane2.trigger_Disallowed( );
    }
    else
    {
      doneRgLane2 = false;
    }
  }

  if ( isIn_RgLane3_Region( ) )
  {
    doneRgLane3 = true;

    if ( isIn_Lane3_State( ) )
    {
      subSM.Lane3.trigger_Disallowed( );
    }
    else
    {
      doneRgLane3 = false;
    }
  }

  if ( isIn_RgLane4_Region( ) )
  {
    doneRgLane4 = true;

    if ( isIn_Lane4_State( ) )
    {
      subSM.Lane4.trigger_Disallowed( );
    }
    else
    {
      doneRgLane4 = false;
    }
  }

  if ( isIn_RgPedestrianLanes_Region( ) )
  {
    doneRgPedestrianLanes = true;

    if ( isIn_PedestrianLanes_State( ) )
    {
      subSM.PedestrianLanes.trigger_Disallowed( );
    }
    else
    {
      doneRgPedestrianLanes = false;
    }
  }
}

void Crossroad::trigger_Open( )
{
  __attribute__( ( unused ) ) bool doneMain = false;
  __attribute__( ( unused ) ) bool doneRgLane1 = false;
  __attribute__( ( unused ) ) bool doneRgLane2 = false;
  __attribute__( ( unused ) ) bool doneRgLane3 = false;
  __attribute__( ( unused ) ) bool doneRgLane4 = false;
  __attribute__( ( unused ) ) bool doneRgPedestrianLanes = false;

  std::lock_guard<std::mutex> lockGuard( guard );

  if ( isIn_RgLane1_Region( ) )
  {
    doneRgLane1 = true;

    if ( isIn_Lane1_State( ) )
    {
      subSM.Lane1.trigger_Open( );
    }
    else
    {
      doneRgLane1 = false;
    }
  }

  if ( isIn_RgLane2_Region( ) )
  {
    doneRgLane2 = true;

    if ( isIn_Lane2_State( ) )
    {
      subSM.Lane2.trigger_Open( );
    }
    else
    {
      doneRgLane2 = false;
    }
  }

  if ( isIn_RgLane3_Region( ) )
  {
    doneRgLane3 = true;

    if ( isIn_Lane3_State( ) )
    {
      subSM.Lane3.trigger_Open( );
    }
    else
    {
      doneRgLane3 = false;
    }
  }

  if ( isIn_RgLane4_Region( ) )
  {
    doneRgLane4 = true;

    if ( isIn_Lane4_State( ) )
    {
      subSM.Lane4.trigger_Open( );
    }
    else
    {
      doneRgLane4 = false;
    }
  }

  if ( isIn_RgPedestrianLanes_Region( ) )
  {
    doneRgPedestrianLanes = true;

    if ( isIn_PedestrianLanes_State( ) )
    {
      subSM.PedestrianLanes.trigger_Open( );
    }
    else
    {
      doneRgPedestrianLanes = false;
    }
  }
}

void Crossroad::trigger_Prepare( )
{
  __attribute__( ( unused ) ) bool doneMain = false;
  __attribute__( ( unused ) ) bool doneRgLane1 = false;
  __attribute__( ( unused ) ) bool doneRgLane2 = false;
  __attribute__( ( unused ) ) bool doneRgLane3 = false;
  __attribute__( ( unused ) ) bool doneRgLane4 = false;
  __attribute__( ( unused ) ) bool doneRgPedestrianLanes = false;

  std::lock_guard<std::mutex> lockGuard( guard );

  if ( isIn_RgLane1_Region( ) )
  {
    doneRgLane1 = true;

    if ( isIn_Lane1_State( ) )
    {
      subSM.Lane1.trigger_Prepare( );
    }
    else
    {
      doneRgLane1 = false;
    }
  }

  if ( isIn_RgLane2_Region( ) )
  {
    doneRgLane2 = true;

    if ( isIn_Lane2_State( ) )
    {
      subSM.Lane2.trigger_Prepare( );
    }
    else
    {
      doneRgLane2 = false;
    }
  }

  if ( isIn_RgLane3_Region( ) )
  {
    doneRgLane3 = true;

    if ( isIn_Lane3_State( ) )
    {
      subSM.Lane3.trigger_Prepare( );
    }
    else
    {
      doneRgLane3 = false;
    }
  }

  if ( isIn_RgLane4_Region( ) )
  {
    doneRgLane4 = true;

    if ( isIn_Lane4_State( ) )
    {
      subSM.Lane4.trigger_Prepare( );
    }
    else
    {
      doneRgLane4 = false;
    }
  }

  if ( isIn_RgPedestrianLanes_Region( ) )
  {
    doneRgPedestrianLanes = true;

    if ( isIn_PedestrianLanes_State( ) )
    {
      subSM.PedestrianLanes.trigger_Prepare( );
    }
    else
    {
      doneRgPedestrianLanes = false;
    }
  }
}

void Crossroad::trigger_StartControlling( )
{
  __attribute__( ( unused ) ) bool doneMain = false;
  __attribute__( ( unused ) ) bool doneRgLane1 = false;
  __attribute__( ( unused ) ) bool doneRgLane2 = false;
  __attribute__( ( unused ) ) bool doneRgLane3 = false;
  __attribute__( ( unused ) ) bool doneRgLane4 = false;
  __attribute__( ( unused ) ) bool doneRgPedestrianLanes = false;

  std::lock_guard<std::mutex> lockGuard( guard );

  if ( isIn_RgLane1_Region( ) )
  {
    doneRgLane1 = true;

    if ( isIn_Lane1_State( ) )
    {
      subSM.Lane1.trigger_StartControlling( );
    }
    else
    {
      doneRgLane1 = false;
    }
  }

  if ( isIn_RgLane2_Region( ) )
  {
    doneRgLane2 = true;

    if ( isIn_Lane2_State( ) )
    {
      subSM.Lane2.trigger_StartControlling( );
    }
    else
    {
      doneRgLane2 = false;
    }
  }

  if ( isIn_RgLane3_Region( ) )
  {
    doneRgLane3 = true;

    if ( isIn_Lane3_State( ) )
    {
      subSM.Lane3.trigger_StartControlling( );
    }
    else
    {
      doneRgLane3 = false;
    }
  }

  if ( isIn_RgLane4_Region( ) )
  {
    doneRgLane4 = true;

    if ( isIn_Lane4_State( ) )
    {
      subSM.Lane4.trigger_StartControlling( );
    }
    else
    {
      doneRgLane4 = false;
    }
  }

  if ( isIn_RgPedestrianLanes_Region( ) )
  {
    doneRgPedestrianLanes = true;

    if ( isIn_PedestrianLanes_State( ) )
    {
      subSM.PedestrianLanes.trigger_StartControlling( );
    }
    else
    {
      doneRgPedestrianLanes = false;
    }
  }
}

void Crossroad::trigger_StopControlling( )
{
  __attribute__( ( unused ) ) bool doneMain = false;
  __attribute__( ( unused ) ) bool doneRgLane1 = false;
  __attribute__( ( unused ) ) bool doneRgLane2 = false;
  __attribute__( ( unused ) ) bool doneRgLane3 = false;
  __attribute__( ( unused ) ) bool doneRgLane4 = false;
  __attribute__( ( unused ) ) bool doneRgPedestrianLanes = false;

  std::lock_guard<std::mutex> lockGuard( guard );

  if ( isIn_RgLane1_Region( ) )
  {
    doneRgLane1 = true;

    if ( isIn_Lane1_State( ) )
    {
      subSM.Lane1.trigger_StopControlling( );
    }
    else
    {
      doneRgLane1 = false;
    }
  }

  if ( isIn_RgLane2_Region( ) )
  {
    doneRgLane2 = true;

    if ( isIn_Lane2_State( ) )
    {
      subSM.Lane2.trigger_StopControlling( );
    }
    else
    {
      doneRgLane2 = false;
    }
  }

  if ( isIn_RgLane3_Region( ) )
  {
    doneRgLane3 = true;

    if ( isIn_Lane3_State( ) )
    {
      subSM.Lane3.trigger_StopControlling( );
    }
    else
    {
      doneRgLane3 = false;
    }
  }

  if ( isIn_RgLane4_Region( ) )
  {
    doneRgLane4 = true;

    if ( isIn_Lane4_State( ) )
    {
      subSM.Lane4.trigger_StopControlling( );
    }
    else
    {
      doneRgLane4 = false;
    }
  }

  if ( isIn_RgPedestrianLanes_Region( ) )
  {
    doneRgPedestrianLanes = true;

    if ( isIn_PedestrianLanes_State( ) )
    {
      subSM.PedestrianLanes.trigger_StopControlling( );
    }
    else
    {
      doneRgPedestrianLanes = false;
    }
  }
}

void Crossroad::trigger_SystemDisabled( )
{
  __attribute__( ( unused ) ) bool doneMain = false;
  __attribute__( ( unused ) ) bool doneRgLane1 = false;
  __attribute__( ( unused ) ) bool doneRgLane2 = false;
  __attribute__( ( unused ) ) bool doneRgLane3 = false;
  __attribute__( ( unused ) ) bool doneRgLane4 = false;
  __attribute__( ( unused ) ) bool doneRgPedestrianLanes = false;
  __attribute__( ( unused ) ) bool doneRgTrafficLight1 = false;
  __attribute__( ( unused ) ) bool doneRgTrafficLight2 = false;
  __attribute__( ( unused ) ) bool doneRgTrafficLight3 = false;
  __attribute__( ( unused ) ) bool doneRgTrafficLight4 = false;
  __attribute__( ( unused ) ) bool doneRgPedestrianLight = false;

  std::lock_guard<std::mutex> lockGuard( guard );

  if ( isIn_RgLane1_Region( ) )
  {
    doneRgLane1 = true;

    if ( isIn_Lane1_State( ) )
    {
      subSM.Lane1.trigger_SystemDisabled( );
    }
    else
    {
      doneRgLane1 = false;
    }
  }

  if ( isIn_RgLane2_Region( ) )
  {
    doneRgLane2 = true;

    if ( isIn_Lane2_State( ) )
    {
      subSM.Lane2.trigger_SystemDisabled( );
    }
    else
    {
      doneRgLane2 = false;
    }
  }

  if ( isIn_RgLane3_Region( ) )
  {
    doneRgLane3 = true;

    if ( isIn_Lane3_State( ) )
    {
      subSM.Lane3.trigger_SystemDisabled( );
    }
    else
    {
      doneRgLane3 = false;
    }
  }

  if ( isIn_RgLane4_Region( ) )
  {
    doneRgLane4 = true;

    if ( isIn_Lane4_State( ) )
    {
      subSM.Lane4.trigger_SystemDisabled( );
    }
    else
    {
      doneRgLane4 = false;
    }
  }

  if ( isIn_RgPedestrianLanes_Region( ) )
  {
    doneRgPedestrianLanes = true;

    if ( isIn_PedestrianLanes_State( ) )
    {
      subSM.PedestrianLanes.trigger_SystemDisabled( );
    }
    else
    {
      doneRgPedestrianLanes = false;
    }
  }

  if ( isIn_RgTrafficLight1_Region( ) )
  {
    doneRgTrafficLight1 = true;

    if ( isIn_TrafficLight1_State( ) )
    {
      subSM.TrafficLight1.trigger_SystemDisabled( );
    }
    else
    {
      doneRgTrafficLight1 = false;
    }
  }

  if ( isIn_RgTrafficLight2_Region( ) )
  {
    doneRgTrafficLight2 = true;

    if ( isIn_TrafficLight2_State( ) )
    {
      subSM.TrafficLight2.trigger_SystemDisabled( );
    }
    else
    {
      doneRgTrafficLight2 = false;
    }
  }

  if ( isIn_RgTrafficLight3_Region( ) )
  {
    doneRgTrafficLight3 = true;

    if ( isIn_TrafficLight3_State( ) )
    {
      subSM.TrafficLight3.trigger_SystemDisabled( );
    }
    else
    {
      doneRgTrafficLight3 = false;
    }
  }

  if ( isIn_RgTrafficLight4_Region( ) )
  {
    doneRgTrafficLight4 = true;

    if ( isIn_TrafficLight4_State( ) )
    {
      subSM.TrafficLight4.trigger_SystemDisabled( );
    }
    else
    {
      doneRgTrafficLight4 = false;
    }
  }

  if ( isIn_RgPedestrianLight_Region( ) )
  {
    doneRgPedestrianLight = true;

    if ( isIn_PedestrianLight_State( ) )
    {
      subSM.PedestrianLight.trigger_SystemDisabled( );
    }
    else
    {
      doneRgPedestrianLight = false;
    }
  }
}

void Crossroad::trigger_SystemEnabled( )
{
  __attribute__( ( unused ) ) bool doneMain = false;
  __attribute__( ( unused ) ) bool doneRgTrafficLight1 = false;
  __attribute__( ( unused ) ) bool doneRgTrafficLight2 = false;
  __attribute__( ( unused ) ) bool doneRgTrafficLight3 = false;
  __attribute__( ( unused ) ) bool doneRgTrafficLight4 = false;
  __attribute__( ( unused ) ) bool doneRgPedestrianLight = false;

  std::lock_guard<std::mutex> lockGuard( guard );

  if ( isIn_RgTrafficLight1_Region( ) )
  {
    doneRgTrafficLight1 = true;

    if ( isIn_TrafficLight1_State( ) )
    {
      subSM.TrafficLight1.trigger_SystemEnabled( );
    }
    else
    {
      doneRgTrafficLight1 = false;
    }
  }

  if ( isIn_RgTrafficLight2_Region( ) )
  {
    doneRgTrafficLight2 = true;

    if ( isIn_TrafficLight2_State( ) )
    {
      subSM.TrafficLight2.trigger_SystemEnabled( );
    }
    else
    {
      doneRgTrafficLight2 = false;
    }
  }

  if ( isIn_RgTrafficLight3_Region( ) )
  {
    doneRgTrafficLight3 = true;

    if ( isIn_TrafficLight3_State( ) )
    {
      subSM.TrafficLight3.trigger_SystemEnabled( );
    }
    else
    {
      doneRgTrafficLight3 = false;
    }
  }

  if ( isIn_RgTrafficLight4_Region( ) )
  {
    doneRgTrafficLight4 = true;

    if ( isIn_TrafficLight4_State( ) )
    {
      subSM.TrafficLight4.trigger_SystemEnabled( );
    }
    else
    {
      doneRgTrafficLight4 = false;
    }
  }

  if ( isIn_RgPedestrianLight_Region( ) )
  {
    doneRgPedestrianLight = true;

    if ( isIn_PedestrianLight_State( ) )
    {
      subSM.PedestrianLight.trigger_SystemEnabled( );
    }
    else
    {
      doneRgPedestrianLight = false;
    }
  }
}

void Crossroad::finalize_Main( )
{
  if ( isIn_Main_Region( ) )
  {
    runningState.Main = Main_States::E_final;
  }
}

void Crossroad::finalize_RgLane1( )
{
  if ( isIn_RgLane1_Region( ) )
  {
    runningState.RgLane1 = RgLane1_States::E_final;
  }
}

void Crossroad::finalize_RgLane2( )
{
  if ( isIn_RgLane2_Region( ) )
  {
    runningState.RgLane2 = RgLane2_States::E_final;
  }
}

void Crossroad::finalize_RgLane3( )
{
  if ( isIn_RgLane3_Region( ) )
  {
    runningState.RgLane3 = RgLane3_States::E_final;
  }
}

void Crossroad::finalize_RgLane4( )
{
  if ( isIn_RgLane4_Region( ) )
  {
    runningState.RgLane4 = RgLane4_States::E_final;
  }
}

void Crossroad::finalize_RgPedestrianLanes( )
{
  if ( isIn_RgPedestrianLanes_Region( ) )
  {
    runningState.RgPedestrianLanes = RgPedestrianLanes_States::E_final;
  }
}

void Crossroad::finalize_RgTrafficLight1( )
{
  if ( isIn_RgTrafficLight1_Region( ) )
  {
    runningState.RgTrafficLight1 = RgTrafficLight1_States::E_final;
  }
}

void Crossroad::finalize_RgTrafficLight2( )
{
  if ( isIn_RgTrafficLight2_Region( ) )
  {
    runningState.RgTrafficLight2 = RgTrafficLight2_States::E_final;
  }
}

void Crossroad::finalize_RgTrafficLight3( )
{
  if ( isIn_RgTrafficLight3_Region( ) )
  {
    runningState.RgTrafficLight3 = RgTrafficLight3_States::E_final;
  }
}

void Crossroad::finalize_RgTrafficLight4( )
{
  if ( isIn_RgTrafficLight4_Region( ) )
  {
    runningState.RgTrafficLight4 = RgTrafficLight4_States::E_final;
  }
}

void Crossroad::finalize_RgPedestrianLight( )
{
  if ( isIn_RgPedestrianLight_Region( ) )
  {
    runningState.RgPedestrianLight = RgPedestrianLight_States::E_final;
  }
}

void Crossroad::terminate( )
{
  finalize_Main( );
}

void Crossroad::init_Main( )
{
  // fork destination -> `:RgLane1:Lane1`
  runningState.Main = Main_States::E_Main;
  init_Lane1( );
  runningState.RgLane1 = RgLane1_States::E_Lane1;

  // fork destination -> `:RgLane2:Lane2`
  runningState.Main = Main_States::E_Main;
  init_Lane2( );
  runningState.RgLane2 = RgLane2_States::E_Lane2;

  // fork destination -> `:RgLane3:Lane3`
  runningState.Main = Main_States::E_Main;
  init_Lane3( );
  runningState.RgLane3 = RgLane3_States::E_Lane3;

  // fork destination -> `:RgLane4:Lane4`
  runningState.Main = Main_States::E_Main;
  init_Lane4( );
  runningState.RgLane4 = RgLane4_States::E_Lane4;

  // fork destination -> `:RgPedestrianLanes:PedestrianLanes`
  runningState.Main = Main_States::E_Main;
  init_PedestrianLanes( );
  runningState.RgPedestrianLanes = RgPedestrianLanes_States::E_PedestrianLanes;

  // fork destination -> `:RgTrafficLight1:TrafficLight1`
  runningState.Main = Main_States::E_Main;
  init_TrafficLight1( );
  runningState.RgTrafficLight1 = RgTrafficLight1_States::E_TrafficLight1;

  // fork destination -> `:RgTrafficLight2:TrafficLight2`
  runningState.Main = Main_States::E_Main;
  init_TrafficLight2( );
  runningState.RgTrafficLight2 = RgTrafficLight2_States::E_TrafficLight2;

  // fork destination -> `:RgTrafficLight3:TrafficLight3`
  runningState.Main = Main_States::E_Main;
  init_TrafficLight3( );
  runningState.RgTrafficLight3 = RgTrafficLight3_States::E_TrafficLight3;

  // fork destination -> `:RgTrafficLight4:TrafficLight4`
  runningState.Main = Main_States::E_Main;
  init_TrafficLight4( );
  runningState.RgTrafficLight4 = RgTrafficLight4_States::E_TrafficLight4;

  // fork destination -> `:RgPedestrianLight:PedestrianLight`
  runningState.Main = Main_States::E_Main;
  init_PedestrianLight( );
  runningState.RgPedestrianLight = RgPedestrianLight_States::E_PedestrianLight;
}

void Crossroad::init_Lane1( )
{
  subSM.Lane1.start( );
}

void Crossroad::init_Lane2( )
{
  subSM.Lane2.start( );
}

void Crossroad::init_Lane3( )
{
  subSM.Lane3.start( );
}

void Crossroad::init_Lane4( )
{
  subSM.Lane4.start( );
}

void Crossroad::init_PedestrianLanes( )
{
  subSM.PedestrianLanes.start( );
}

void Crossroad::init_TrafficLight1( )
{
  subSM.TrafficLight1.start( );
}

void Crossroad::init_TrafficLight2( )
{
  subSM.TrafficLight2.start( );
}

void Crossroad::init_TrafficLight3( )
{
  subSM.TrafficLight3.start( );
}

void Crossroad::init_TrafficLight4( )
{
  subSM.TrafficLight4.start( );
}

void Crossroad::init_PedestrianLight( )
{
  subSM.PedestrianLight.start( );
}

void Crossroad::exit_Lane1( )
{
  runningState.RgLane1 = RgLane1_States::E_Lane1;

  subSM.Lane1.deinitialize( );
}

void Crossroad::exit_Lane2( )
{
  runningState.RgLane2 = RgLane2_States::E_Lane2;

  subSM.Lane2.deinitialize( );
}

void Crossroad::exit_Lane3( )
{
  runningState.RgLane3 = RgLane3_States::E_Lane3;

  subSM.Lane3.deinitialize( );
}

void Crossroad::exit_Lane4( )
{
  runningState.RgLane4 = RgLane4_States::E_Lane4;

  subSM.Lane4.deinitialize( );
}

void Crossroad::exit_PedestrianLanes( )
{
  runningState.RgPedestrianLanes = RgPedestrianLanes_States::E_PedestrianLanes;

  subSM.PedestrianLanes.deinitialize( );
}

void Crossroad::exit_TrafficLight1( )
{
  runningState.RgTrafficLight1 = RgTrafficLight1_States::E_TrafficLight1;

  subSM.TrafficLight1.deinitialize( );
}

void Crossroad::exit_TrafficLight2( )
{
  runningState.RgTrafficLight2 = RgTrafficLight2_States::E_TrafficLight2;

  subSM.TrafficLight2.deinitialize( );
}

void Crossroad::exit_TrafficLight3( )
{
  runningState.RgTrafficLight3 = RgTrafficLight3_States::E_TrafficLight3;

  subSM.TrafficLight3.deinitialize( );
}

void Crossroad::exit_TrafficLight4( )
{
  runningState.RgTrafficLight4 = RgTrafficLight4_States::E_TrafficLight4;

  subSM.TrafficLight4.deinitialize( );
}

void Crossroad::exit_PedestrianLight( )
{
  runningState.RgPedestrianLight = RgPedestrianLight_States::E_PedestrianLight;

  subSM.PedestrianLight.deinitialize( );
}

// End of Crossroad.cpp
